---
name: Improve GPT Interview Prompt Structure
overview: Улучшить системный и пользовательский промпты для GPT-интервьюера, проводящего скрининг-собеседование, чтобы четко объяснить роль интервьюера, правила работы с динамическими вопросами, оставшимся временем, уточняющими вопросами и переспросами. Обеспечить структурированный JSON ответ.
todos:
  - id: "1"
    content: Переписать _build_session_system_prompt() с четкими правилами, менять текст о динамических вопросах в зависимости от allow_dynamic_questions
    status: pending
  - id: "2"
    content: Улучшить _build_session_user_prompt() - всегда указывать следующий вопрос из шаблона, добавить инструкции о возможности задать динамический вопрос перед ним
    status: pending
  - id: "3"
    content: Проверить и обновить логику в _process_user_response() для обработки динамических вопросов - если isDynamic=true, после ответа пользователя снова отправить следующий вопрос из шаблона
    status: pending
  - id: "4"
    content: Обновить _handle_start_session() для генерации приветственного промпта с вопросом о готовности. Добавить логику обработки ответа о готовности - если не готов, GPT может попросить подать сигнал
    status: pending
  - id: "5"
    content: Реализовать таймер только когда пользователь должен отвечать (мяч на стороне пользователя) - таймер останавливается когда AI говорит, запускается когда пользователь должен отвечать
    status: pending
  - id: "6"
    content: Добавить восстановление сессии при повторном входе - проверка незавершенной сессии, UI для продолжения, загрузка истории транскрипта
    status: pending
  - id: "7"
    content: Обновить _build_gpt_context() для передачи полной истории при восстановлении сессии - включить все предыдущие вопросы и ответы, указать следующий вопрос на который не успели ответить
    status: pending
  - id: "8"
    content: Добавить логику использования customer_simulation в конце интервью - проверять наличие симуляции, определять когда интервью подходит к концу, добавлять инструкции в промпт о проведении симуляции
    status: pending
  - id: "9"
    content: Реализовать обработку окончания времени интервью - вывести сообщение о завершении, дать возможность пользователю задать доп вопрос или дополнение, сохранить эту информацию
    status: pending
---

## Текущее состояние

В `backend/app/services/openai_service.py` есть методы:

- `_build_session_system_prompt()` - формирует системный промпт
- `_build_session_user_prompt()` - формирует пользовательский промпт с контекстом
- `generate_session_question_with_json_mode()` - вызывает GPT с JSON mode

Текущий промпт недостаточно четко объясняет:

- Роль интервьюера для скрининг-собеседования в конкретной компании и позиции
- Правила работы с флагом `allow_dynamic_questions`
- Логику работы с оставшимся временем
- Правила использования уточняющих вопросов
- Когда можно переспрашивать вопросы

## Задачи

### 1. Улучшить системный промпт (`_build_session_system_prompt`)

Добавить четкие инструкции:

- **Роль**: "Ты AI-интервьюер, проводящий скрининг-собеседование в компанию {company} на позицию {position}"
- **Динамические вопросы**: 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                - Если `allow_dynamic_questions = false`: можно задавать ТОЛЬКО вопросы из шаблона и их уточняющие подвопросы
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                - Если `allow_dynamic_questions = true`: можно добавлять свои вопросы, но вопросы из шаблона в приоритете
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                - ВАЖНО: Не класть условие в сам промпт, а менять текст промпта в зависимости от значения поля
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                - В промпте всегда даем следующий вопрос из шаблона, но GPT может решить задать дополнительный вопрос перед ним
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                - Если GPT вернет `isDynamic = true`, после ответа пользователя нужно снова послать следующий вопрос из шаблона
- **Оставшееся время**: Если времени остается мало (например, < 5 минут), НЕ задавай дополнительные вопросы, даже если разрешены динамические. Если времени много, можно задавать уточняющие вопросы.
- **Уточняющие вопросы**: К каждому основному вопросу могут быть привязаны подвопросы. Используй их, если ответ кандидата недостаточно точен или если есть потенциально важный момент, который стоит уточнить.
- **Задавать по одному**: Всегда задавай вопросы по одному, не задавай несколько вопросов сразу.
- **Переспрос**: Если времени много, а кандидат дал совсем невнятный ответ, можно переспросить тот же вопрос, но сформулировав его по-другому.
- **Customer Simulation (моделирование реальной рабочей ситуации)**: Если в конфиге интервью заполнено `customer_simulation` (enabled = true), то в конце интервью (когда все основные вопросы из шаблона заданы или осталось мало времени) можно провести симуляцию. GPT должен сыграть роль клиента согласно сценарию (role и scenario из конфига).

### 2. Улучшить пользовательский промпт (`_build_session_user_prompt`)

Структурировать контекст более четко:

- Явно указать оставшееся время и его влияние на поведение
- Четко показать текущий вопрос из шаблона и его уточняющие подвопросы
- Указать, разрешены ли динамические вопросы
- Показать историю диалога для контекста
- Добавить инструкции о том, когда задавать уточняющие вопросы

### 3. Логика начала сессии

При открытии сессии (`_handle_start_session`):

- **Приветственный промпт**: Должен быть приветственный вопрос типа "Здравствуйте! Я провожу скрининг-собеседование в компанию {company} на позицию {position}. Готовы ли вы начать?"
- **Обработка ответа о готовности**: 
                                - Если пользователь отвечает, что готов - летит первый вопрос из шаблона
                                - Если пользователь отвечает, что не готов - GPT может попросить подать сигнал о готовности (например, "Пожалуйста, дайте знать, когда будете готовы начать")
                                - После того как пользователь подтвердит готовность, задается первый вопрос из шаблона

### 4. Таймер сессии

**Требования:**
- Таймер должен идти ТОЛЬКО когда "мяч на стороне пользователя" (когда пользователь должен отвечать)
- Таймер останавливается когда AI говорит/генерирует вопрос
- Таймер запускается когда пользователь должен отвечать (после того как AI задал вопрос)
- При восстановлении сессии таймер должен показывать оставшееся время с учетом уже прошедшего времени
- **Обработка окончания времени**: Когда время вышло (таймер достиг 0), нужно:
  - Вывести сообщение пользователю: "Время интервью истекло. Интервью завершено."
  - Дать возможность пользователю задать дополнительный вопрос или дополнение
  - Сохранить эту дополнительную информацию в базе данных
  - После этого завершить сессию

**Реализация:**
- В frontend (`SessionView.tsx`): добавить состояние `isUserTurn` - когда true, таймер идет
- Останавливать таймер при получении сообщения от AI (`role: "ai"`)
- Запускать таймер после того как AI закончил говорить и пользователь должен отвечать
- При восстановлении сессии вычислять оставшееся время: `duration - (current_time - started_at)`

### 5. Восстановление незавершенной сессии

**Требования:**
- Если пользователь переходит по той же ссылке или перезагружает страницу, сессия должна восстановиться
- При входе в незавершенную сессию (status = IN_PROGRESS) показывать окошко "Продолжить сессию"
- При восстановлении загружать полную историю транскрипта из базы данных
- Первый промпт при восстановлении должен содержать:
  - Полную историю вопросов и ответов
  - Следующий вопрос из шаблона, на который пользователь не успел ответить в прошлый раз

**Реализация:**

Backend (`backend/app/api/public.py`):
- В методе `start_session()` проверять, существует ли уже активная сессия для этого токена
- Если сессия существует и status = IN_PROGRESS, возвращать информацию о незавершенной сессии
- Добавить флаг `isResume` в ответ

Backend (`backend/app/websocket/session.py`):
- При подключении к существующей сессии загружать историю транскрипта из `SessionTranscript`
- Загружать историю вопросов-ответов из `SessionQuestionAnswer`
- Передавать полную историю в `_build_gpt_context()` при восстановлении
- Определять следующий вопрос из шаблона, на который еще не был дан ответ

Frontend (`AI Tutor Dashboard-8/src/components/SessionView.tsx` или новый компонент):
- При загрузке сессии проверять флаг `isResume`
- Если `isResume = true`, показывать диалог "Продолжить сессию?"
- При подтверждении загружать историю транскрипта и восстанавливать состояние
- Восстанавливать таймер с правильным оставшимся временем

### 6. Уточнить JSON схему ответа

Убедиться, что ответ соответствует схеме `GPTResponse`:

- `question.text` - текст вопроса
- `question.type` - "main" | "clarifying" | "dynamic"
- `question.isDynamic` - является ли вопрос дополнительным (динамическим)
- `question.isClarifying` - является ли вопрос уточняющим
- `metadata.answerQuality` - качество последнего ответа
- `metadata.shouldMoveNext` - нужно ли переходить к следующему вопросу

## Файлы для изменения

1. **backend/app/services/openai_service.py**:
   - Метод `_build_session_system_prompt()` - переписать с четкими инструкциями, менять текст в зависимости от `allow_dynamic_questions`, добавить правила о customer_simulation
   - Метод `_build_session_user_prompt()` - улучшить структуру и добавить логику по времени, всегда указывать следующий вопрос из шаблона, добавлять информацию о customer_simulation если оно заполнено

2. **backend/app/websocket/session.py**:
   - Метод `_handle_start_session()` - обновить для генерации приветственного промпта с вопросом о готовности
   - Метод `_process_user_response()` - добавить логику обработки ответа о готовности (если не готов - попросить подать сигнал, если готов - задать первый вопрос)
   - Проверить логику обработки ответа с `isDynamic = true` - после ответа пользователя на динамический вопрос нужно снова отправить следующий вопрос из шаблона
   - При подключении к существующей сессии загружать историю транскрипта и вопросов-ответов
   - Обновить `_build_gpt_context()` для передачи полной истории при восстановлении сессии и информации о customer_simulation
   - Добавить логику определения конца интервью (все вопросы заданы или осталось мало времени)
   - При активации симуляции создавать `SimulationScenario` и сохранять диалог в `SimulationDialog`

3. **backend/app/api/public.py**:
   - Метод `start_session()` - проверять существующую незавершенную сессию, возвращать флаг `isResume`

4. **Frontend компоненты**:
   - `AI Tutor Dashboard-8/src/components/SessionView.tsx` - добавить логику таймера (только когда пользователь должен отвечать), обработку истечения времени, сообщение о завершении и возможность отправить доп вопрос/дополнение
   - Создать компонент для диалога "Продолжить сессию?" при восстановлении
   - Загружать и отображать историю транскрипта при восстановлении

5. **Модель данных** (опционально):
   - Рассмотреть добавление поля для дополнительной информации после истечения времени (можно использовать существующее поле `SessionTranscript` с пометкой или добавить отдельное поле в `Session`)

## Детали реализации

### Системный промпт должен включать:

```
Ты AI-интервьюер, проводящий скрининг-собеседование в компанию {company} на позицию {position}.

ВАЖНО: Это скрининг-собеседование (первичный отбор), а не полное интервью. Цель - быстро оценить базовые компетенции, мотивацию и коммуникативные навыки кандидата.

ПРАВИЛА ПОВЕДЕНИЯ:

0. ПРИВЕТСТВИЕ И ПРОВЕРКА ГОТОВНОСТИ (только при старте сессии):
   - При первом сообщении поздоровайся и спроси о готовности: "Здравствуйте! Я провожу скрининг-собеседование в компанию {company} на позицию {position}. Готовы ли вы начать?"
   - Если кандидат отвечает, что готов (да, конечно, готов и т.д.) - задай первый вопрос из шаблона
   - Если кандидат отвечает, что не готов (нет, подождите, не готов и т.д.) - вежливо попроси подать сигнал о готовности: "Хорошо, пожалуйста, дайте знать, когда будете готовы начать"
   - Если ответ неясный - уточни готовность

1. ДИНАМИЧЕСКИЕ ВОПРОСЫ (текст меняется в зависимости от allow_dynamic_questions):
   
   Если allow_dynamic_questions = false:
   - Ты можешь задавать ТОЛЬКО вопросы из шаблона и их уточняющие подвопросы
   - Не придумывай свои вопросы
   
   Если allow_dynamic_questions = true:
   - Ты можешь задавать дополнительные вопросы, если считаешь это необходимым
   - НО вопросы из шаблона всегда в приоритете
   - Если в контексте указан следующий вопрос из шаблона, сначала задай его, а дополнительные вопросы задавай только если это действительно важно для оценки кандидата

2. ОСТАВШЕЕСЯ ВРЕМЯ:
   - Если времени < 5 минут: НЕ задавай дополнительные вопросы, даже если разрешены
   - Если времени много: можешь задавать уточняющие вопросы для лучшего понимания
   - Если время истекло: интервью завершено, но пользователь может задать дополнительный вопрос или дополнение

3. УТОЧНЯЮЩИЕ ВОПРОСЫ:
   - Используй подвопросы из шаблона, если ответ кандидата недостаточно точен
   - Если есть потенциально важный момент, который стоит уточнить - уточни его
   - Задавай уточняющие вопросы по одному

4. ПЕРЕСПРОС:
   - Если времени много и кандидат дал невнятный ответ - можешь переспросить вопрос, сформулировав его по-другому

5. ЗАДАВАЙ ВОПРОСЫ ПО ОДНОМУ - никогда не задавай несколько вопросов сразу

6. МОДЕЛИРОВАНИЕ РЕАЛЬНОЙ РАБОЧЕЙ СИТУАЦИИ (customer_simulation):
   - Если в конфиге указано customer_simulation с enabled = true, то в конце интервью (когда все основные вопросы заданы или осталось < 5 минут) можно провести симуляцию
   - Ты должен сыграть роль клиента согласно сценарию:
     * Роль клиента: {role}
     * Описание сценария: {scenario}
   - Веди себя как указанный клиент (например, недовольный клиент, гость, заказчик)
   - Задавай вопросы или высказывай претензии от лица этого клиента
   - Оценивай реакцию кандидата на стрессовую ситуацию
   - Симуляция должна быть реалистичной и соответствовать описанному сценарию
   - После симуляции можно завершить интервью

ФОРМАТ ОТВЕТА: Только JSON согласно структуре...
```

### Пользовательский промпт должен включать:

- Четкое указание оставшегося времени и его влияния
- **Следующий вопрос из шаблона** (всегда указывать, даже если GPT может задать дополнительный)
- Уточняющие подвопросы для следующего вопроса из шаблона
- История диалога
- Последний ответ кандидата
- Инструкции: "Следующий вопрос из шаблона: {question}. Ты можешь задать его, или если разрешены динамические вопросы, можешь сначала задать свой дополнительный вопрос (укажи isDynamic = true), а затем задать вопрос из шаблона"

**При наличии customer_simulation:**
- Если все основные вопросы из шаблона заданы ИЛИ осталось < 5 минут:
  - Указать: "Интервью подходит к концу. Если в конфиге есть customer_simulation, ты можешь провести симуляцию реальной рабочей ситуации."
  - Передать информацию о симуляции:
    * Роль клиента: {customer_simulation.role}
    * Сценарий: {customer_simulation.scenario}
  - Инструкция: "Сыграй роль этого клиента и проведи симуляцию. Веди себя соответственно сценарию."

**При восстановлении сессии:**
- Добавить в начало промпта: "ВАЖНО: Сессия была прервана и восстановлена. Ниже полная история диалога. Следующий вопрос из шаблона, на который кандидат не успел ответить: {question}"
- Передать полную историю всех вопросов и ответов из `SessionTranscript` и `SessionQuestionAnswer`
- Указать, что нужно продолжить с того места, где остановились

### Логика начала сессии:

В `backend/app/websocket/session.py` в методе `_handle_start_session()`:

- При старте сессии генерировать приветственный промпт через GPT
- Промпт должен содержать: "Здравствуйте! Я провожу скрининг-собеседование в компанию {company} на позицию {position}. Готовы ли вы начать?"
- Сохранить состояние "ожидание подтверждения готовности" в session_state

В методе `_process_user_response()`:

- Проверять, находится ли сессия в состоянии "ожидание подтверждения готовности"
- Если да, анализировать ответ пользователя:
  - Если готов (положительный ответ) - задать первый вопрос из шаблона, сбросить флаг ожидания
  - Если не готов (отрицательный ответ) - GPT может попросить подать сигнал о готовности, оставить флаг ожидания
  - Если неясный ответ - уточнить готовность

### Логика обработки динамических вопросов:

В `backend/app/websocket/session.py` в методе `_process_user_response()`:

- После получения ответа от GPT проверять `gpt_response.question.isDynamic`
- Если `isDynamic = true`, после сохранения ответа пользователя на динамический вопрос, нужно снова вызвать GPT с тем же следующим вопросом из шаблона
- Это позволит задать вопрос из шаблона после динамического вопроса

### Логика таймера:

В frontend (`AI Tutor Dashboard-8/src/components/SessionView.tsx`):

- Добавить состояние `isUserTurn: boolean` - указывает, должен ли пользователь отвечать
- Добавить состояние `timeExpired: boolean` - указывает, истекло ли время интервью
- Таймер работает только когда `isUserTurn === true` и `timeExpired === false`
- При достижении таймером 0:
  - Установить `timeExpired = true`
  - Остановить таймер
  - Отправить сообщение на backend о завершении времени
  - Показать пользователю сообщение: "Время интервью истекло. Интервью завершено. Если у вас есть дополнительный вопрос или дополнение, вы можете его озвучить - эта информация будет добавлена к результатам."
  - Разрешить пользователю отправить еще одно сообщение (доп вопрос или дополнение)
- При получении сообщения от AI (`role: "ai"`):
  - Установить `isUserTurn = false` (таймер останавливается)
  - После окончания воспроизведения аудио установить `isUserTurn = true` (таймер запускается, если время не истекло)
- При отправке ответа пользователя:
  - Установить `isUserTurn = false` (таймер останавливается, пока AI обрабатывает)
- При восстановлении сессии:
  - Вычислить оставшееся время: `duration - (current_time - started_at)`
  - Если время истекло, установить `timeExpired = true`
  - Если последнее сообщение от AI - `isUserTurn = true`, иначе `isUserTurn = false`

В backend (`backend/app/websocket/session.py`):

- При получении сообщения о завершении времени (таймер = 0):
  - Отправить сообщение пользователю: "Время интервью истекло. Интервью завершено. Если у вас есть дополнительный вопрос или дополнение, вы можете его озвучить - эта информация будет добавлена к результатам."
  - Установить флаг `time_expired = true` в session_state
  - Разрешить пользователю отправить еще одно сообщение (доп вопрос/дополнение)
- При получении дополнительного сообщения после истечения времени:
  - Сохранить это сообщение как дополнительную информацию (можно в отдельное поле или в SessionTranscript с пометкой)
  - После этого завершить сессию (установить status = COMPLETED)

### Логика использования customer_simulation:

В `backend/app/websocket/session.py`:

- В методе `_build_gpt_context()` проверять наличие `customer_simulation` в `interview.config`
- Если `customer_simulation.enabled = true`, передавать информацию о симуляции в контекст
- Определять, когда интервью подходит к концу:
  - Все основные вопросы из шаблона заданы (проверить по `question_progress`)
  - ИЛИ осталось < 5 минут времени
- В пользовательском промпте указывать возможность провести симуляцию в конце
- При активации симуляции:
  - Создать `SimulationScenario` для сессии (если еще не создан)
  - Сохранять диалог симуляции в `SimulationDialog`
  - GPT должен играть роль клиента согласно сценарию
  - После симуляции можно завершить интервью

В `backend/app/services/openai_service.py`:

- В `_build_session_user_prompt()` добавлять информацию о customer_simulation, если оно заполнено
- Добавлять инструкции о том, когда и как провести симуляцию

### Логика восстановления сессии:

В `backend/app/api/public.py` в методе `start_session()`:

- Проверять, существует ли уже сессия для данного токена с `status = IN_PROGRESS`
- Если существует, возвращать:
  ```json
  {
    "sessionId": "...",
    "isResume": true,
    "session": {
      "id": "...",
      "status": "in_progress",
      "startedAt": "...",
      ...
    }
  }
  ```

В `backend/app/websocket/session.py` при подключении:

- Если сессия уже существует и `status = IN_PROGRESS`:
  - Загрузить все `SessionTranscript` записи для этой сессии
  - Загрузить все `SessionQuestionAnswer` записи
  - Определить следующий вопрос из шаблона (первый вопрос, на который еще нет ответа)
  - Отправить клиенту полную историю транскрипта
  - При следующем запросе от пользователя передать полную историю в `_build_gpt_context()`

В frontend при получении `isResume = true`:

- Показать диалог: "Обнаружена незавершенная сессия. Продолжить?"
- При подтверждении:
  - Загрузить историю транскрипта из ответа API
  - Восстановить состояние компонента
  - Вычислить и установить правильное оставшееся время
  - Установить `isUserTurn` в зависимости от последнего сообщения